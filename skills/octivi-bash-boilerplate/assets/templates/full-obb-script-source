#!/usr/bin/env bash
# shellcheck shell=bash
#/
#/ Example script based on Octivi Bash Boilerplate.
#/
#/ Usage:
#/   script.sh -o <output-path> [-v] [-h]
#/
#/ Options:
#/   -o <path>  Required output path.
#/   -v         Verbose logging.
#/   -h         Show this help.
#/
#/ Environment:
#/   OBB_PATH   Optional explicit path for sourced OBB library

# >>> OBB:BEGIN variant=header source=local version=local
################################################################################
# Octivi Bash Boilerplate (OBB) Header
# Part of Octivi Bash Boilerplate https://github.com/octivi/bash-boilerplate
################################################################################
# Unofficial Bash "Strict Mode"
# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail
# Define common constants regardless if they are used in the script
__my_name="$(basename "${BASH_SOURCE[0]}")"
readonly __my_name
__my_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly __my_dir
__my_path="${__my_dir}/${__my_name}"
# shellcheck disable=SC2034
readonly __my_path
__my_args="$*"
# shellcheck disable=SC2034
readonly __my_args
# Set IFS to just newline and tab
IFS=$'\n\t'
################################################################################
# <<< OBB:END

obb_lib_path="${OBB_PATH:-}"
if [[ -z "${obb_lib_path}" ]] && command -v octivi-bash-boilerplate > /dev/null 2>&1; then
  obb_lib_path="$(command -v octivi-bash-boilerplate)"
fi
if [[ -z "${obb_lib_path}" ]]; then
  obb_lib_path="${__my_dir}/octivi-bash-boilerplate"
fi
if [[ ! -r "${obb_lib_path}" && -r "${__my_dir}/octivi-bash-boilerplate" ]]; then
  obb_lib_path="${__my_dir}/octivi-bash-boilerplate"
fi
readonly obb_lib_path

if [[ ! -r "${obb_lib_path}" ]]; then
  printf 'ERROR: Cannot read Octivi Bash Boilerplate at "%s". Set OBB_PATH if needed.\n' "${obb_lib_path}" >&2
  exit 2
fi

# shellcheck source=/dev/null
# shellcheck disable=SC1091
source "${obb_lib_path}"

VERBOSE=0
OUTPUT_PATH=""
TEMP_FILE=""

cleanup() {
  local rc=$?
  if [[ -n "${TEMP_FILE}" && -f "${TEMP_FILE}" ]]; then
    rm -f "${TEMP_FILE}"
  fi
  if (( rc != 0 )); then
    warning "Exiting with status ${rc}"
  fi
}

parse_args() {
  local opt
  while getopts ":o:vh" opt; do
    case "${opt}" in
      o) OUTPUT_PATH="${OPTARG}" ;;
      v) VERBOSE=1 ;;
      h)
        usage
        exit 0
        ;;
      :)
        die 2 "Option -${OPTARG} requires an argument."
        ;;
      \?)
        die 2 "Unknown option: -${OPTARG}"
        ;;
    esac
  done
  shift $((OPTIND - 1))

  if [[ -z "${OUTPUT_PATH}" ]]; then
    die 2 "Missing required option: -o <output-path>"
  fi

  if (($# > 0)); then
    die 2 "Unexpected positional arguments: $*"
  fi
}

main() {
  parse_args "$@"
  trap cleanup EXIT

  TEMP_FILE="$(mktemp)"
  printf 'Generated by %s from %s\n' "${__my_name}" "${__my_dir}" > "${TEMP_FILE}"
  mv "${TEMP_FILE}" "${OUTPUT_PATH}"
  TEMP_FILE=""

  if (( VERBOSE == 1 )); then
    ok "Wrote output to ${OUTPUT_PATH}"
  fi
}

main "$@"
