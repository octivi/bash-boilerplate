#!/usr/bin/env bash
# SPDX-FileCopyrightText: 2026  IMAGIN sp. z o.o.
# SPDX-FileContributor: Marcin Engelmann <mengelmann@octivi.com>
# SPDX-License-Identifier: MIT
#
# Part of Octivi Bash Boilerplate https://github.com/octivi/bash-boilerplate
#
#/ Usage: update-octivi-bash-boilerplate [OPTIONS] <file> [file...]
#/
#/ Update inlined Octivi Bash Boilerplate blocks in one or more files.
#/
#/ Options:
#/   -u, --use VERSION         Use release assets from version (e.g. 1.1.1 or v1.1.1)
#/   --variant full|header
#/                             Force target variant for all blocks
#/   -h, --help                Show this help
#/
#/ Environment:
#/   OBB_REPO                  GitHub repo for release assets (default: octivi/bash-boilerplate)
#/   OBB_RELEASE_BASE_URL      Override release base URL

# <<< OBB:BEGIN variant=header
# Octivi Bash Boilerplate (OBB) Header
# Part of Octivi Bash Boilerplate https://github.com/octivi/bash-boilerplate
################################################################################
# Unofficial Bash "Strict Mode"
# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail
# Define common constants regardless if they are used in the script
__my_name="$(basename "${BASH_SOURCE[0]}")"
readonly __my_name
__my_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly __my_dir
__my_path="${__my_dir}/${__my_name}"
# shellcheck disable=SC2034
readonly __my_path
__my_args="$*"
# shellcheck disable=SC2034
readonly __my_args
# Set IFS to just newline and tab
IFS=$'\n\t'
################################################################################
# <<< OBB:END

readonly __repo="${OBB_REPO:-octivi/bash-boilerplate}"
readonly __release_base_default="https://github.com/${__repo}/releases/download"
tmp_dir=''

normalize_tag() {
  local version="$1"
  if [[ ${version} == v* ]]; then
    printf "%s" "${version}"
  else
    printf "v%s" "${version}"
  fi
}

download_asset() {
  local url="$1"
  local dst="$2"
  if ! curl -fsSL "${url}" -o "${dst}"; then
    error "Failed to download ${url}"
    return 1
  fi
}

verify_checksum_file() {
  local dir="$1"
  local checksum_file="$2"
  if ! [[ -s "${dir}/${checksum_file}" ]]; then
    error "Checksum file is missing or empty: ${checksum_file}"
    return 1
  fi

  if ! (cd "${dir}" && sha256sum -c "${checksum_file}" > /dev/null 2>&1); then
    error "Checksum verification failed: ${checksum_file}"
    return 1
  fi
}

extract_variant_from_marker() {
  local marker_line="$1"
  if [[ ${marker_line} =~ variant=(full|header) ]]; then
    printf "%s" "${BASH_REMATCH[1]}"
  fi
}

emit_block_source() {
  local variant="$1"
  local source_file="$2"
  local line=''
  local strip=0

  if [[ ${variant} != 'header' ]]; then
    cat "${source_file}"
    return 0
  fi

  while IFS= read -r line || [[ -n ${line} ]]; do
    if [[ ${line} == '# OBB:STRIP-BEGIN' ]]; then
      strip=1
      continue
    fi
    if [[ ${line} == '# OBB:STRIP-END' ]]; then
      strip=0
      continue
    fi
    if (( strip == 1 )); then
      continue
    fi
    printf "%s\n" "${line}"
  done < "${source_file}"
}

process_marked_blocks() {
  local target="$1"
  local requested_variant_arg="$2"
  local source_name="$3"
  local source_version="$4"
  local source_full_file="$5"
  local source_header_file="$6"

  local tmp_out=''
  local line=''
  local in_block=0
  local block_count=0
  local marker_variant=''
  local chosen_variant=''
  local source_file=''

  tmp_out="$(mktemp "${tmp_dir}/marked-out.XXXXXX")"
  : > "${tmp_out}"

  while IFS= read -r line || [[ -n ${line} ]]; do
    if (( in_block == 0 )); then
      if [[ ${line} =~ ^#\ \>\>\>\ OBB:BEGIN($|\ ) ]]; then
        in_block=1
        block_count=$((block_count + 1))
        marker_variant="$(extract_variant_from_marker "${line}")"
        continue
      fi

      if [[ ${line} == '# <<< OBB:END' ]]; then
        error "File ${target}: OBB END marker without matching BEGIN marker"
        return 1
      fi

      printf "%s\n" "${line}" >> "${tmp_out}"
      continue
    fi

    if [[ ${line} == '# <<< OBB:END' ]]; then
      chosen_variant="${requested_variant_arg}"
      if [[ -z ${chosen_variant} ]]; then
        chosen_variant="${marker_variant}"
      fi

      case "${chosen_variant}" in
        full) source_file="${source_full_file}" ;;
        header) source_file="${source_header_file}" ;;
        *)
          error "File ${target}: missing variant for marked OBB block #${block_count}; set variant=full|header in marker or pass --variant"
          return 1
          ;;
      esac

      build_block "${chosen_variant}" "${source_name}" "${source_version}" "${source_file}" >> "${tmp_out}"
      in_block=0
      marker_variant=''
      continue
    fi

    if [[ ${line} =~ ^#\ \>\>\>\ OBB:BEGIN($|\ ) ]]; then
      error "File ${target}: nested OBB BEGIN marker is not supported"
      return 1
    fi

  done < "${target}" || {
    error "Cannot read file: ${target}"
    return 5
  }

  if (( in_block == 1 )); then
    error "File ${target}: OBB BEGIN marker without matching END marker"
    return 1
  fi

  if (( block_count == 0 )); then
    return 4
  fi

  if ! chmod --reference="${target}" "${tmp_out}"; then
    error "Cannot apply file mode from ${target}"
    return 5
  fi
  if cmp -s "${target}" "${tmp_out}"; then
    return 3
  fi

  if ! mv "${tmp_out}" "${target}"; then
    error "Cannot write updated content to ${target}"
    return 5
  fi
}

build_block() {
  local variant="$1"
  local source_name="$2"
  local source_version="$3"
  local source_file="$4"

  {
    printf "# >>> OBB:BEGIN variant=%s source=%s version=%s\n" "${variant}" "${source_name}" "${source_version}"
    emit_block_source "${variant}" "${source_file}"
    if [[ -n $(tail -c1 "${source_file}" || true) ]]; then
      printf "\n"
    fi
    printf "# <<< OBB:END\n"
  }
}

cleanup() {
  if [[ -n ${tmp_dir} && -d ${tmp_dir} ]]; then
    rm -rf "${tmp_dir}"
  fi
}

main() {
  local requested_version=''
  local requested_variant=''
  local source_name='local'
  local source_version='local'
  local source_full_file="${__my_dir}/octivi-bash-boilerplate"
  local source_header_file="${__my_dir}/octivi-bash-boilerplate-header"
  local target=''
  local rc=0
  local updated_count=0
  local skipped_count=0
  local failed_count=0
  local total_count=0
  local tag=''
  local base_url=''
  declare -a targets=()

  while (( $# > 0 )); do
    case "$1" in
      -u|--use)
        (( $# >= 2 )) || { error "Missing value for $1"; usage; return 2; }
        requested_version="$2"
        shift 2
        ;;
      --variant)
        (( $# >= 2 )) || { error "Missing value for $1"; usage; return 2; }
        requested_variant="$2"
        shift 2
        ;;
      -h|--help)
        usage
        return 0
        ;;
      --)
        shift
        while (( $# > 0 )); do
          targets+=("$1")
          shift
        done
        ;;
      -*)
        error "Unknown option: $1"
        usage
        return 2
        ;;
      *)
        targets+=("$1")
        shift
        ;;
    esac
  done

  if (( ${#targets[@]} == 0 )); then
    error "At least one target file is required"
    usage
    return 2
  fi

  case "${requested_variant}" in
    ''|full|header) ;;
    *)
      error "Invalid --variant value: ${requested_variant}. Expected full or header."
      return 2
      ;;
  esac

  require_command chmod
  require_command cmp
  require_command grep
  require_command mktemp
  require_command mv
  require_command tail

  tmp_dir="$(mktemp -d "${TMPDIR:-/tmp}/${__my_name}.XXXXXX")"
  trap cleanup EXIT

  if [[ -n ${requested_version} ]]; then
    require_command curl
    require_command sha256sum

    tag="$(normalize_tag "${requested_version}")"
    base_url="${OBB_RELEASE_BASE_URL:-${__release_base_default}}"
    source_name='github'
    source_version="${tag}"
    source_full_file="${tmp_dir}/octivi-bash-boilerplate"
    source_header_file="${tmp_dir}/octivi-bash-boilerplate-header"

    download_asset "${base_url}/${tag}/octivi-bash-boilerplate" "${source_full_file}"
    download_asset "${base_url}/${tag}/octivi-bash-boilerplate.sha256" "${tmp_dir}/octivi-bash-boilerplate.sha256"
    download_asset "${base_url}/${tag}/octivi-bash-boilerplate-header" "${source_header_file}"
    download_asset "${base_url}/${tag}/octivi-bash-boilerplate-header.sha256" "${tmp_dir}/octivi-bash-boilerplate-header.sha256"

    verify_checksum_file "${tmp_dir}" "octivi-bash-boilerplate.sha256"
    verify_checksum_file "${tmp_dir}" "octivi-bash-boilerplate-header.sha256"
  fi

  if ! [[ -r "${source_full_file}" ]]; then
    error "Cannot read source file: ${source_full_file}"
    return 1
  fi
  if ! [[ -r "${source_header_file}" ]]; then
    error "Cannot read source file: ${source_header_file}"
    return 1
  fi

  for target in "${targets[@]}"; do
    if ! [[ -f "${target}" ]]; then
      error "File not found: ${target}"
      failed_count=$((failed_count + 1))
      continue
    fi
    if ! [[ -r "${target}" ]]; then
      error "Cannot read file: ${target}"
      failed_count=$((failed_count + 1))
      continue
    fi

    rc=0
    process_marked_blocks "${target}" "${requested_variant}" "${source_name}" "${source_version}" "${source_full_file}" "${source_header_file}" || rc=$?
    if (( rc == 0 )); then
      ok "UPDATED ${target} (mode=marked, source=${source_name}, version=${source_version})"
      updated_count=$((updated_count + 1))
      continue
    fi
    if (( rc == 3 )); then
      warning "SKIPPED ${target} (already up to date)"
      skipped_count=$((skipped_count + 1))
      continue
    fi
    if (( rc != 4 )); then
      failed_count=$((failed_count + 1))
      continue
    fi

    warning "SKIPPED ${target} (no marked OBB block found)"
    skipped_count=$((skipped_count + 1))
  done

  total_count=$((updated_count + skipped_count + failed_count))
  print "SUMMARY total=${total_count} updated=${updated_count} skipped=${skipped_count} failed=${failed_count}"

  if (( failed_count > 0 )); then
    return 1
  fi
}

# >>> OBB:BEGIN variant=full
# SPDX-FileCopyrightText: 2016-2026  IMAGIN sp. z o.o.
# SPDX-FileContributor: Marcin Engelmann <mengelmann@octivi.com>
# SPDX-License-Identifier: MIT
#
# Part of Octivi Bash Boilerplate https://github.com/octivi/bash-boilerplate
#
# Specify the shell for ShellCheck since we do not use a shebang here
# shellcheck shell=bash

################################################################################
# Define colors and formatting
#
# Define colors ANSI 4-bit colors
#   - https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
#   - https://misc.flogisoft.com/bash/tip_colors_and_formatting
#   - https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux
#   - https://superuser.com/q/301353
################################################################################

# \x1b (ESC Escape) is hex equivalent of Bash '\e' that can be used more widely.
# Foreground                         # Background
readonly __c_black=$'\x1b[0;30m';    readonly __c_b_black=$'\x1b[0;40m'    #  0. Black
readonly __c_red=$'\x1b[0;31m';      readonly __c_b_red=$'\x1b[0;41m'      #  1. Red
readonly __c_green=$'\x1b[0;32m';    readonly __c_b_green=$'\x1b[0;42m'    #  2. Green
readonly __c_yellow=$'\x1b[0;33m';   readonly __c_b_yellow=$'\x1b[0;43m'   #  3. Yellow
readonly __c_blue=$'\x1b[0;34m';     readonly __c_b_blue=$'\x1b[0;44m'     #  4. Blue
readonly __c_magenta=$'\x1b[0;35m';  readonly __c_b_magenta=$'\x1b[0;45m'  #  5. Magenta
readonly __c_cyan=$'\x1b[0;36m';     readonly __c_b_cyan=$'\x1b[0;46m'     #  6. Cyan
readonly __c_white=$'\x1b[0;37m';    readonly __c_b_white=$'\x1b[0;47m'    #  7. White
readonly __c_grey=$'\x1b[1;30m';     readonly __c_b_grey=$'\x1b[1;40m'     #  8. Bright Black (Grey)
readonly __c_bred=$'\x1b[1;31m';     readonly __c_b_bred=$'\x1b[1;41m'     #  9. Bright Red
readonly __c_bgreen=$'\x1b[1;32m';   readonly __c_b_bgreen=$'\x1b[1;42m'   # 10. Bright Green
readonly __c_byellow=$'\x1b[1;33m';  readonly __c_b_byellow=$'\x1b[1;43m'  # 11. Bright Yellow
readonly __c_bblue=$'\x1b[1;34m';    readonly __c_b_bblue=$'\x1b[1;44m'    # 12. Bright Blue
readonly __c_bmagenta=$'\x1b[1;35m'; readonly __c_b_bmagenta=$'\x1b[1;45m' # 13. Bright Magenta
readonly __c_bcyan=$'\x1b[1;36m';    readonly __c_b_bcyan=$'\x1b[1;46m'    # 14. Bright Cyan
readonly __c_bwhite=$'\x1b[1;37m';   readonly __c_b_bwhite=$'\x1b[1;47m'   # 15. Bright White
readonly __c_default=$'\x1b[0;39m';  readonly __c_b_default=$'\x1b[0;49m'  # Default color

readonly __c_bld=$'\x1b[1m'     # Bold text
readonly __c_und=$'\x1b[4m'     # Underline text
readonly __c_inv=$'\x1b[7m'     # Inverse: swap background and foreground colors
readonly __c_reg=$'\x1b[22;24m' # Regular text only, keep colors
readonly __c_rst=$'\x1b[0m'     # Reset all attributes

readonly __c_error="${__c_red}"
readonly __c_warning="${__c_yellow}"
readonly __c_ok="${__c_green}"

################################################################################
# Print help message
#
# Usage: usage
#
# Outputs: Help message defined in the script code, prefixed with '#/'
################################################################################
function usage() {
  # __my_path is assigned in script that includes this library
  # shellcheck disable=SC2154
  printf "%b\n" "$(grep '^#/' "${__my_path}" | cut -c4-)" 1>&2
}

################################################################################
# Output current timestamp in ISO 8601 format (2020-02-11T08:56:00+0000) to stdout
#
# Usage: now
#        echo "$(now)"
#
# Outputs: timestamp
################################################################################
function now() {
  printf '%(%Y-%m-%dT%H:%M:%S%z)T' -1
}

################################################################################
# Read lines from stdin and call a function for each line
#
# Usage: __read_stdin_lines <function_name>
#
# Outputs: None
# Returns: 0 when stdin is piped and all calls succeed, 1 otherwise
################################################################################
function __read_stdin_lines() {
  local func="$1" line
  shift
  (($# == 0)) && [[ -p /dev/stdin ]] || return 1
  # No arguments and stdin is opened, so read message from stdin and execute the function for each line
  while read -r line; do "${func}" "${line}"; done
}

################################################################################
# Output timestamp and message to stdout
#
# Usage: echo "message to print on stdout" | print
#        print [message to print on stdout]
#
# Outputs: timestamp and message
################################################################################
function print() {
  __read_stdin_lines print "$@" && return
  printf '%s %b\n' "$(now)" "$*"
}

################################################################################
# Print error message to stderr
#
# Usage: echo "message to print on stderr" | error
#        error [message to print on stderr]
#
# Outputs: message
################################################################################
function error() {
  __read_stdin_lines error "$@" && return
  if [[ -z ${NO_COLOR-} || -n ${FORCE_COLOR-} ]]; then print "${__c_error}ERROR: $*${__c_rst}" 1>&2; else print "ERROR: $*" 1>&2; fi
}

################################################################################
# Print warning message to stderr
#
# Usage: echo "message to print on stderr" | warning
#        warning [message to print on stderr]
#
# Outputs: message
################################################################################
function warning() {
  __read_stdin_lines warning "$@" && return
  if [[ -z ${NO_COLOR-} || -n ${FORCE_COLOR-} ]]; then print "${__c_warning}WARN: $*${__c_rst}" 1>&2; else print "WARN: $*" 1>&2; fi
}

################################################################################
# Print OK message to stdout
#
# Usage: echo "message to print on stdout" | ok
#        ok [message to print on stdout]
#
# Outputs: message
################################################################################
function ok() {
  __read_stdin_lines ok "$@" && return
  if [[ -z ${NO_COLOR-} || -n ${FORCE_COLOR-} ]]; then print "${__c_ok}OK: $*${__c_rst}"; else print "OK: $*"; fi
}

################################################################################
# Print a bigger header to stdout
#
# Usage: echo "header to print on stdout" | header
#        header [header to print on stdout]
#
# Outputs: header
################################################################################
function header() {
  __read_stdin_lines header "$@" && return
  print "##########"; print "# $*"; print "##########"
}

################################################################################
# Show a rotating spinner on stdout
#
# Based on https://mywiki.wooledge.org/BashFAQ/034 and vendored 1-char spinners
# from https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json
#
# Usage: spin [spinner_name, defaults to 'dots'] &
#        spin_pid=$!
#        # long-running commands here
#        kill "${spin_pid}"; wait "${spin_pid}" 2>/dev/null
#
# Outputs: spinner animation
################################################################################
function spin() {
  local spinner="${1:-dots}"
  local i=0
  local sp=''
  local n=0
  local tty_fd=0
  local locale="${LC_ALL:-${LC_CTYPE:-${LANG:-}}}"

  if [[ ${locale^^} != *UTF-8* && ${locale^^} != *UTF8* ]]; then
    spinner='line'
  fi

  case "${spinner}" in
    dots) sp='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏' ;;
    dots2) sp='⣾⣽⣻⢿⡿⣟⣯⣷' ;;
    sand) sp='⠁⠂⠄⡀⡈⡐⡠⣀⣁⣂⣄⣌⣔⣤⣥⣦⣮⣶⣷⣿⡿⠿⢟⠟⡛⠛⠫⢋⠋⠍⡉⠉⠑⠡⢁' ;;
    line) sp='-\|/' ;;
    dqpb) sp='dqpb' ;;
    *) sp='-\|/' ;;
  esac

  n=${#sp}
  printf ' '
  { exec {tty_fd}</dev/tty; } 2>/dev/null || return 0
  while :; do
    printf '\b%s' "${sp:i++%n:1}"
    IFS= read -r -t 0.1 -u "${tty_fd}" || true
  done
}

################################################################################
# Print an optional message and exit with either the given status or that of the most recent command
#
# Based on https://mywiki.wooledge.org/BashFAQ/101
#
# Usage: some_command || die [status code] [message to print on exit]
#        die [status code] [message to print on exit]
#
# Outputs: message
################################################################################
function die() {
  # Get the exit code of the most recent command.
  local ret=$?

  # At least one argument and it is a number, use as an exit code
  if (( $# > 0 )) && [[ $1 =~ ^[0-9]+$ ]]; then ret="$1"; shift; fi

  # Still at least one argument, use all of them as a message
  if (( $# > 0 )); then if (( ret != 0 )); then error "$*"; else print "$*"; fi; fi
  exit "${ret}"
}

################################################################################
# Check if this instance of bash version is at least X.Y
#
# Usage: require_bash_version [major] [minor]
#        require_bash_version 4 4 || die 2 "At least Bash 4.4 is required"
#
# Returns: 0 if bash version is at least required; 1 if bash version is older
################################################################################
function require_bash_version() {
  (( BASH_VERSINFO[0] > $1 || (BASH_VERSINFO[0] == $1 && BASH_VERSINFO[1] >= $2) ))
}

################################################################################
# Check if required command is available
#
# Usage: require_command [required command] || die 2 "Cannot find 'X'. Install 'xxx' package"
#        require_command [required command] || die 2
#
# Returns: 0 if required command is available; 1 if required command is not available
################################################################################
function require_command() {
  type -P "$1" > /dev/null
}

################################################################################
# Check if script is being run by root user
#
# Usage: require_root || die 2 "This script must be run as root"
#        require_root && die 2 "This script must not be run as root"
#
# Returns: 0 if being run as root; 1 if not being run as root
################################################################################
function require_root() {
  (( EUID == 0 ))
}

################################################################################
# Check if script is piped
#
# Usage: is_piped
#
# Returns: 0 if output is piped; 1 if output is not piped
################################################################################
function is_piped() {
  [[ ! -t 1 ]]
}

################################################################################
# Check if script is sourced
#
# Usage: is_sourced
#
# Returns: 0 if being sourced; 1 if not being sourced
#################################################################################
function is_sourced() {
  [[ "${BASH_SOURCE[0]}" != "$0" ]]
}

################################################################################
# Check if script is interactive
#
# Based on https://mywiki.wooledge.org/BashFAQ/109
#
# Usage: is_interactive
#
# Returns: 0 if interactive; 1 if not interactive
#################################################################################
function is_interactive() {
  [[ $- == *i* || -t 0 ]]
}

# Minimum supported Bash version for Octivi Bash Boilerplate is Bash 4.4
require_bash_version 4 4 || { echo "At least Bash 4.4 is required"; is_sourced && return 2 || exit 2; }

# Disable colors if script is piped
if is_piped; then
  NO_COLOR=1
fi

# Run main only when executed directly; do nothing when sourced.
if ! is_sourced; then
  main "$@"
fi
# <<< OBB:END
