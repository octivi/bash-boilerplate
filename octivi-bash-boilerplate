# SPDX-FileCopyrightText: 2016-2026  IMAGIN sp. z o.o.
# SPDX-FileContributor: Marcin Engelmann <mengelmann@octivi.com>
# SPDX-License-Identifier: MIT
#
# Part of Octivi Bash Boilerplate https://github.com/octivi/bash-boilerplate
#
# Specify the shell for ShellCheck since we do not use a shebang here
# shellcheck shell=bash

################################################################################
# Define colors and formatting
#
# Define colors ANSI 4-bit colors
#   - https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
#   - https://misc.flogisoft.com/bash/tip_colors_and_formatting
#   - https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux
#   - https://superuser.com/q/301353
################################################################################

# \x1b (ESC Escape) is hex equivalent of Bash '\e' that can be used more widely.
# Foreground                         # Background
readonly __c_black=$'\x1b[0;30m';    readonly __c_b_black=$'\x1b[0;40m'    #  0. Black
readonly __c_red=$'\x1b[0;31m';      readonly __c_b_red=$'\x1b[0;41m'      #  1. Red
readonly __c_green=$'\x1b[0;32m';    readonly __c_b_green=$'\x1b[0;42m'    #  2. Green
readonly __c_yellow=$'\x1b[0;33m';   readonly __c_b_yellow=$'\x1b[0;43m'   #  3. Yellow
readonly __c_blue=$'\x1b[0;34m';     readonly __c_b_blue=$'\x1b[0;44m'     #  4. Blue
readonly __c_magenta=$'\x1b[0;35m';  readonly __c_b_magenta=$'\x1b[0;45m'  #  5. Magenta
readonly __c_cyan=$'\x1b[0;36m';     readonly __c_b_cyan=$'\x1b[0;46m'     #  6. Cyan
readonly __c_white=$'\x1b[0;37m';    readonly __c_b_white=$'\x1b[0;47m'    #  7. White
readonly __c_grey=$'\x1b[1;30m';     readonly __c_b_grey=$'\x1b[1;40m'     #  8. Bright Black (Grey)
readonly __c_bred=$'\x1b[1;31m';     readonly __c_b_bred=$'\x1b[1;41m'     #  9. Bright Red
readonly __c_bgreen=$'\x1b[1;32m';   readonly __c_b_bgreen=$'\x1b[1;42m'   # 10. Bright Green
readonly __c_byellow=$'\x1b[1;33m';  readonly __c_b_byellow=$'\x1b[1;43m'  # 11. Bright Yellow
readonly __c_bblue=$'\x1b[1;34m';    readonly __c_b_bblue=$'\x1b[1;44m'    # 12. Bright Blue
readonly __c_bmagenta=$'\x1b[1;35m'; readonly __c_b_bmagenta=$'\x1b[1;45m' # 13. Bright Magenta
readonly __c_bcyan=$'\x1b[1;36m';    readonly __c_b_bcyan=$'\x1b[1;46m'    # 14. Bright Cyan
readonly __c_bwhite=$'\x1b[1;37m';   readonly __c_b_bwhite=$'\x1b[1;47m'   # 15. Bright White
readonly __c_default=$'\x1b[0;39m';  readonly __c_b_default=$'\x1b[0;49m'  # Default color

readonly __c_bld=$'\x1b[1m'     # Bold text
readonly __c_und=$'\x1b[4m'     # Underline text
readonly __c_inv=$'\x1b[7m'     # Inverse: swap background and foreground colors
readonly __c_reg=$'\x1b[22;24m' # Regular text only, keep colors
readonly __c_rst=$'\x1b[0m'     # Reset all attributes

readonly __c_error="${__c_red}"
readonly __c_warning="${__c_yellow}"
readonly __c_ok="${__c_green}"


################################################################################
# Print help message
#
# Usage: usage
#
# Outputs: Help message defined in the script code, prefixed with '#/'
################################################################################
function usage() {
  # __my_path is assigned in script that includes this library
  # shellcheck disable=SC2154
  printf "%b\n" "$(grep '^#/' "${__my_path}" | cut -c4-)" 1>&2
}


################################################################################
# Output current timestamp in ISO 8601 format (2020-02-11T08:56:00+0000) to stdout
#
# Usage: now
#        echo "$(now)"
#
# Outputs: timestamp
################################################################################
function now() {
  printf '%(%Y-%m-%dT%H:%M:%S%z)T' -1
}


################################################################################
# Output timestamp and message to stdout
#
# Usage: echo "message to print on stdout" | print
#        print [message to print on stdout]
#
# Outputs: timestamp and message
################################################################################
function print() {
  if (($# == 0)) && [[ -p /dev/stdin ]]; then
    # No arguments and stdin is opened, so read message from stdin
    while read -r line; do
      print "${line}"
    done
  else
    # Message passed as an argument
    printf '%s %b\n' "$(now)" "$*"
  fi
}


################################################################################
# Print error message to stderr
#
# Usage: echo "message to print on stderr" | error
#        error [message to print on stderr]
#
# Outputs: message
################################################################################
function error() {
  if (($# == 0)) && [[ -p /dev/stdin ]]; then
    # No arguments and stdin is opened, so read message from stdin
    while read -r line; do
      error "${line}"
    done
  else
    # Message passed as an argument
    if [[ -z ${NO_COLOR-} || -n ${FORCE_COLOR-} ]]; then
      print "${__c_error}ERROR: $*${__c_rst}" 1>&2
    else
      print "ERROR: $*" 1>&2
    fi
  fi
}


################################################################################
# Print warning message to stderr
#
# Usage: echo "message to print on stderr" | warning
#        warning [message to print on stderr]
#
# Outputs: message
################################################################################
function warning() {
  if (($# == 0)) && [[ -p /dev/stdin ]]; then
    # No arguments and stdin is opened, so read message from stdin
    while read -r line; do
      warning "${line}"
    done
  else
    # Message passed as an argument
    if [[ -z ${NO_COLOR-} || -n ${FORCE_COLOR-} ]]; then
      print "${__c_warning}WARN: $*${__c_rst}" 1>&2
    else
      print "WARN: $*" 1>&2
    fi
  fi
}


################################################################################
# Print OK message to stdout
#
# Usage: echo "message to print on stdout" | ok
#        ok [message to print on stdout]
#
# Outputs: message
################################################################################
function ok() {
  if (($# == 0)) && [[ -p /dev/stdin ]]; then
    # No arguments and stdin is opened, so read message from stdin
    while read -r line; do
      ok "${line}"
    done
  else
    # Message passed as an argument
    if [[ -z ${NO_COLOR-} || -n ${FORCE_COLOR-} ]]; then
      print "${__c_ok}OK: $*${__c_rst}"
    else
      print "OK: $*"
    fi
  fi
}


################################################################################
# Print a bigger header to stdout
#
# Usage: echo "header to print on stdout" | header
#        header [header to print on stdout]
#
# Outputs: header
################################################################################
function header() {
  if (($# == 0)) && [[ -p /dev/stdin ]]; then
    # No arguments and stdin is opened, so read header from stdin
    while read -r line; do
      header "${line}"
    done
  else
    # Message passed as an argument
    print "##########"
    print "# $*"
    print "##########"
  fi
}


################################################################################
# Show a rotating spinner on stdout (Bash, with GNU sleep)
#
# Based on https://mywiki.wooledge.org/BashFAQ/034 and vendored 1-char spinners
# from https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json
#
# Usage: spin [spinner_name, defaults to 'dots'] &
#        spin_pid=$!
#        # long-running commands here
#        kill "${spin_pid}"; wait "${spin_pid}" 2>/dev/null
#
# Outputs: spinner animation
################################################################################
function spin() {
  local spinner="${1:-dots}"
  local i=0
  local sp=''
  local interval='0.13'
  local n=0
  local locale="${LC_ALL:-${LC_CTYPE:-${LANG:-}}}"
  local spinner_data name data_interval data_sp

  if [[ ${locale^^} != *UTF-8* && ${locale^^} != *UTF8* ]]; then
    spinner='line'
  fi

  # name<TAB>interval_in_seconds<TAB>frames
  read -r -d '' spinner_data <<'EOF' || true
dots	0.08	⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏
dots2	0.08	⣾⣽⣻⢿⡿⣟⣯⣷
dots3	0.08	⠋⠙⠚⠞⠖⠦⠴⠲⠳⠓
dots4	0.08	⠄⠆⠇⠋⠙⠸⠰⠠⠰⠸⠙⠋⠇⠆
dots5	0.08	⠋⠙⠚⠒⠂⠂⠒⠲⠴⠦⠖⠒⠐⠐⠒⠓⠋
dots6	0.08	⠁⠉⠙⠚⠒⠂⠂⠒⠲⠴⠤⠄⠄⠤⠴⠲⠒⠂⠂⠒⠚⠙⠉⠁
dots7	0.08	⠈⠉⠋⠓⠒⠐⠐⠒⠖⠦⠤⠠⠠⠤⠦⠖⠒⠐⠐⠒⠓⠋⠉⠈
dots8	0.08	⠁⠁⠉⠙⠚⠒⠂⠂⠒⠲⠴⠤⠄⠄⠤⠠⠠⠤⠦⠖⠒⠐⠐⠒⠓⠋⠉⠈⠈
dots9	0.08	⢹⢺⢼⣸⣇⡧⡗⡏
dots10	0.08	⢄⢂⢁⡁⡈⡐⡠
dots11	0.1	⠁⠂⠄⡀⢀⠠⠐⠈
dots13	0.08	⣼⣹⢻⠿⡟⣏⣧⣶
dots8Bit	0.08	⠀⠁⠂⠃⠄⠅⠆⠇⡀⡁⡂⡃⡄⡅⡆⡇⠈⠉⠊⠋⠌⠍⠎⠏⡈⡉⡊⡋⡌⡍⡎⡏⠐⠑⠒⠓⠔⠕⠖⠗⡐⡑⡒⡓⡔⡕⡖⡗⠘⠙⠚⠛⠜⠝⠞⠟⡘⡙⡚⡛⡜⡝⡞⡟⠠⠡⠢⠣⠤⠥⠦⠧⡠⡡⡢⡣⡤⡥⡦⡧⠨⠩⠪⠫⠬⠭⠮⠯⡨⡩⡪⡫⡬⡭⡮⡯⠰⠱⠲⠳⠴⠵⠶⠷⡰⡱⡲⡳⡴⡵⡶⡷⠸⠹⠺⠻⠼⠽⠾⠿⡸⡹⡺⡻⡼⡽⡾⡿⢀⢁⢂⢃⢄⢅⢆⢇⣀⣁⣂⣃⣄⣅⣆⣇⢈⢉⢊⢋⢌⢍⢎⢏⣈⣉⣊⣋⣌⣍⣎⣏⢐⢑⢒⢓⢔⢕⢖⢗⣐⣑⣒⣓⣔⣕⣖⣗⢘⢙⢚⢛⢜⢝⢞⢟⣘⣙⣚⣛⣜⣝⣞⣟⢠⢡⢢⢣⢤⢥⢦⢧⣠⣡⣢⣣⣤⣥⣦⣧⢨⢩⢪⢫⢬⢭⢮⢯⣨⣩⣪⣫⣬⣭⣮⣯⢰⢱⢲⢳⢴⢵⢶⢷⣰⣱⣲⣳⣴⣵⣶⣷⢸⢹⢺⢻⢼⢽⢾⢿⣸⣹⣺⣻⣼⣽⣾⣿
sand	0.08	⠁⠂⠄⡀⡈⡐⡠⣀⣁⣂⣄⣌⣔⣤⣥⣦⣮⣶⣷⣿⡿⠿⢟⠟⡛⠛⠫⢋⠋⠍⡉⠉⠑⠡⢁
line	0.13	-\|/
arrow	0.1	←↖↑↗→↘↓↙
dqpb	0.1	dqpb
layer	0.15	-=≡
EOF

  while IFS=$'\t' read -r name data_interval data_sp; do
    if [[ ${name} == "${spinner}" ]]; then
      interval="${data_interval}"
      sp="${data_sp}"
      break
    fi
  done <<< "${spinner_data}"

  [[ -n ${sp} ]] || sp='-\|/'

  n=${#sp}
  printf ' '
  while sleep "${interval}"; do
    printf '\b%s' "${sp:i++%n:1}"
  done
}


################################################################################
# Print an optional message and exit with either the given status or that of the most recent command
#
# Based on https://mywiki.wooledge.org/BashFAQ/101
#
# Usage: some_command || die [status code] [message to print on exit]
#        die [status code] [message to print on exit]
#
# Outputs: message
################################################################################
function die() {
  # Get the exit code of the most recent command.
  local ret=$?

  if (( $# > 0 )) && [[ $1 != *[^0-9]* ]]; then
    # At least one argument and it is a number, use as an exit code
    ret="$1"
    shift
  fi

  if (( $# > 0 )); then
    # Still at least one argument, use all of them as a message
    local -r message="$*"
    if (( ret != 0 )); then
      error "${message}"
    else
      print "${message}"
    fi
  fi
  exit "${ret}"
}


################################################################################
# Check if this instance of bash version is at least X.Y
#
# Usage: require_bash_version [major] [minor]
#        require_bash_version 4 4 || die 2 "At least Bash 4.4 is required"
#
# Returns: 0 if bash version is at least required; 1 if bash version is older
################################################################################
function require_bash_version() {
  (( BASH_VERSINFO[0] > $1 || (BASH_VERSINFO[0] == $1 && BASH_VERSINFO[1] >= $2) ))
  return
}


################################################################################
# Check if required command is available
#
# Usage: require_command [required command] || die 2 "Cannot find 'X'. Install 'xxx' package"
#        require_command [required command] || die 2
#
# Returns: 0 if required command is available; 1 if required command is not available
################################################################################
function require_command() {
  type -P "$1" > /dev/null
  return
}


################################################################################
# Check if script is being run by root user
#
# Usage: require_root || die 2 "This script must be run as root"
#        require_root && die 2 "This script must not be run as root"
#
# Returns: 0 if being run as root; 1 if not being run as root
################################################################################
function require_root() {
  (( EUID == 0 ))
  return
}


################################################################################
# Check if script is piped
#
# Usage: is_piped
#
# Returns: 0 if output is piped; 1 if output is not piped
################################################################################
function is_piped() {
  [[ ! -t 1 ]]
  return
}


################################################################################
# Check if script is sourced
#
# Usage: is_sourced
#
# Returns: 0 if being sourced; 1 if not being sourced
#################################################################################
function is_sourced() {
  [[ "${BASH_SOURCE[0]}" != "$0" ]]
  return
}


################################################################################
# Check if script is interactive
#
# Based on https://mywiki.wooledge.org/BashFAQ/109
#
# Usage: is_interactive
#
# Returns: 0 if interactive; 1 if not interactive
#################################################################################
function is_interactive() {
  [[ $- == *i* ]] && return 0
  [[ -t 0 ]]
  return
}


# Minimum supported Bash version for Octivi Bash Boilerplate is Bash 4.4
require_bash_version 4 4 || { echo "At least Bash 4.4 is required"; is_sourced && return 2 || exit 2; }

# Disable colors if script is piped
if is_piped; then
  NO_COLOR=1
fi
